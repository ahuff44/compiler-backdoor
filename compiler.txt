let RESERVED = _array("true", "false", "let", "def", "if", "while", "print", "return", "break", "do", "raise", "alloc");
let SYNTAX = _array("=", ";", "(", ")", ",", "{", "}");
let BINOPS = _array("+", "-", "*", "==", "!=", "<", ">", "<=", ">=", "||", "&&");
let ALL_SYMBOLS = SYNTAX.concat(BINOPS);

def is_symbol_character(char) {
  def is_relevant_symbol(sym) {
    return sym.includes(char);
  }
  return _any(ALL_SYMBOLS, is_relevant_symbol);
}

let DIGITS = _array("0","1","2","3","4","5","6","7","8","9");
let LOWERCASE = _array("a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z");
let UPPERCASE = _array("A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z");

def tokenize(text) {
  let state = "NONE";
  let buffer = _array();
  let text = text + " ";

  let tokens = _array();
  let ix1 = 0;
  while (ix1 < text.length) {
    let char = _get(text, ix1);
    # do _print(_array(ix1, char, state));
    if (state == "COMMENT") {
      if (char == "\n") {
        let state = "NONE";
      }
    } else if (state == "STRING") {
      if (char == "\\") {
        let state = "ESCAPE_CHAR";
      } else if (char != "\"") {
        do buffer.push(char);
      } else {
        do tokens.push(_array(state, buffer.join("")));
        let state = "NONE";
      }
    } else if (state == "ESCAPE_CHAR") {
      let to_push = char;
      if (char == "n") {
        let to_push = "\n";
      } else if (char == "t") {
        let to_push = "\t";
      }
      do buffer.push(to_push);
      let state = "STRING";
    } else if (state == "INTEGER") {
      if (DIGITS.includes(char)) {
        do buffer.push(char);
      } else {
        do tokens.push(_array(state, buffer.join("")));
        let state = "NONE";
        let ix1 = ix1 - 1; # redo
      }
    } else if (state == "SYMBOL") {
      def validity_filter(sym) {
        # checks whether sym is a prefix of buffer
        let ix2 = 0;
        while (ix2 < sym.length) {
          let cbuf = _get(buffer, ix2);
          let sbuf = _get(sym, ix2);
          if (cbuf != sbuf) {
            return false;
          }
          let ix2 = ix2 + 1;
        }
        return true;
      }
      def by_length(s1, s2) {
        return s1.length > s2.length;
      }

      if (is_symbol_character(char)) {
        do buffer.push(char);
      } else {
        while (buffer.length != 0) {
          # do _print(_array("buffer", buffer));
          let valid_prefixes = ALL_SYMBOLS.filter(validity_filter);
          let valid_prefixes = valid_prefixes.sort(by_length); # hack b/c a.b().c() doesn't work
          if (valid_prefixes.length == 0) {
            raise "unrecognized symbols: " + buffer.join("");
          }

          let to_push = valid_prefixes.pop();
          do tokens.push(_array(state, to_push));

          # buffer.shuft(to_push.length)
          let ix3 = 0;
          while (ix3 < to_push.length) {
            do _leftpop(buffer);
            let ix3 = ix3 + 1;
          }
        }
        let state = "NONE";
        let ix1 = ix1 - 1; # redo
      }
    } else if (state == "IDENTIFIER") {
      if ((char == ".") || (char == "_") || DIGITS.includes(char) || LOWERCASE.includes(char) || UPPERCASE.includes(char)) {
        do buffer.push(char);
      } else {
        let val = buffer.join("");
        if (RESERVED.includes(val)) {
          do tokens.push(_array("RESERVED", val));
        } else {
          do tokens.push(_array(state, val));
        }
        let state = "NONE";
        let ix1 = ix1 - 1; # redo
      }
    } else if (state == "NONE") {
      if ((char == " ") || (char == "\t") || (char == "\n")) {
        # no-op
      } else if (char == "#") {
        let state = "COMMENT";
      } else if (char == "\"") {
        let state = "STRING";
        let buffer = _array();
      } else if (DIGITS.includes(char)) {
        let state = "INTEGER";
        let buffer = _array();
        let ix1 = ix1 - 1; # redo
      } else if ((char == "_") || LOWERCASE.includes(char) || UPPERCASE.includes(char)) {
        let state = "IDENTIFIER";
        let buffer = _array();
        let ix1 = ix1 - 1; # redo
      } else if (is_symbol_character(char)) {
        let state = "SYMBOL";
        let buffer = _array();
        let ix1 = ix1 - 1; # redo
      } else {
        raise "unrecognized character: " + char;
      }
    } else {
      raise "iae: illegal state: " + state;
    }
    let ix1 = ix1 + 1;
  }
  return tokens;
}

def parse_entrypoint(tokens) {
  let prefix = _array(_array("SYMBOL", "{"));
  let tokens = prefix.concat(tokens);
  do tokens.push(_array("SYMBOL", "}"));
  do tokens.reverse(); # convinient for next_token_ etc
  let ast = parse_("SCOPE", tokens);
  if (tokens.length != 0) {
    raise "trailing tokens";
  } else {
    return ast;
  }
}

def next_token_(tokens) {
  return tokens.pop();
}

def peek(tokens) {
  return _get(tokens, tokens.length - 1);
}

def tok_eq(tok1, sym, val) {
  return (_get(tok1, 0) == sym) && (_get(tok1, 1) == val);
}

def parse_(state, tokens) {
  # do _print(_array("parse_", state, peek(tokens)));

  if (state == "SCOPE") {
    let tok = next_token_(tokens);
    if (false == tok_eq(tok, "SYMBOL", "{")) {
      raise "scope missing '{': " + _get(tok, 1);
    }
    alloc ast;
    let ast = _array();
    while (true) {
      if (tok_eq(peek(tokens), "SYMBOL", "}")) {
        do next_token_(tokens);
        return _array("SCOPE", ast);
      }
      do ast.push(parse_("STATEMENT", tokens));
    }
  } else if (state == "LET") {
    let target = next_token_(tokens);
    if (false == (_get(target, 0) == "IDENTIFIER")) {
      raise "bad let target: " + _get(tok, 1);
    }

    let tok = next_token_(tokens);
    if (false == tok_eq(tok, "SYMBOL", "=")) {
      raise "missing '=': " + _get(tok, 1);
    }

    let rhs = parse_("EXPRESSION", tokens);

    let tok = next_token_(tokens);
    if (false == tok_eq(tok, "SYMBOL", ";")) {
      raise "missing ';': " + _get(tok, 1);
    }

    return _array("LET", target, rhs);
  } else if (state == "EXPRESSION") {
    let tok = next_token_(tokens);
    let type = _get(tok, 0);
    let val = _get(tok, 1);
    if (type == "STRING") {
      let lhs = tok;
    } else if (type == "INTEGER") {
      let lhs = tok;
    } else if (type == "RESERVED") {
      if (false == ((val == "true") || (val == "false"))) {
        raise "reserved word in expression: " + val;
      }
      let lhs = tok;
    } else if (type == "IDENTIFIER") {
      let tok2 = peek(tokens);
      if (tok_eq(tok2, "SYMBOL", "(")) {
        do tokens.push(tok); # put func name back
        let lhs = parse_("CALL", tokens);
      } else {
        let lhs = tok;
      }
    } else if (type == "SYMBOL") {
      if (tok_eq(tok, "SYMBOL", "(")) {
        let lhs = parse_("EXPRESSION", tokens);
        let paren_tok = next_token_(tokens);
        if (false == tok_eq(paren_tok, "SYMBOL", ")")) {
          raise "missing ')': " + _get(paren_tok, 1);
        }
      }
    } else {
      raise "iae";
    }

    # do _print(_array("lhs", lhs, peek(tokens)));

    let tok = next_token_(tokens);
    let type = _get(tok, 0);
    let val = _get(tok, 1);
    if (type == "SYMBOL") {
      if (BINOPS.includes(val)) {
        return _array("BINOP", tok, lhs, parse_("EXPRESSION", tokens));
      } else { # e.g. ')', ';', or ','
        do tokens.push(tok); # put it back
        return lhs;
      }
    } else {
      raise "bad expression " + val;
    }
  } else if (state == "CALL") {
    let name_ = next_token_(tokens);
    if (_get(name_, 0) != "IDENTIFIER") {
      raise "bad call name: " + _get(name_, 1);
    }

    let paren_tok = next_token_(tokens);
    if (false == tok_eq(paren_tok, "SYMBOL", "(")) {
      raise "missing '(': " + _get(paren_tok, 1);
    }

    let args = parse_("EXPLIST", tokens);

    let paren_tok = next_token_(tokens);
    if (false == tok_eq(paren_tok, "SYMBOL", ")")) {
      raise "missing ')': " + _get(paren_tok, 1);
    }

    return _array("CALL", name_, args);
  } else if (state == "DO") {
    let call = parse_("CALL", tokens);

    let semi_tok = next_token_(tokens);
    if (false == tok_eq(semi_tok, "SYMBOL", ";")) {
      raise "missing ';': " + _get(semi_tok, 1);
    }

    return _array("DO", call);
  } else if (state == "EXPLIST") {
    if (tok_eq(peek(tokens), "SYMBOL", ")")) {
      return _array();
    } else {
      let buffer = _array();
      while (true) {
        do buffer.push(parse_("EXPRESSION", tokens));
        let popped = next_token_(tokens);
        if (false == tok_eq(popped, "SYMBOL", ",")) {
          do tokens.push(popped); # return the token
            return buffer;
        }
      }
    }
  } else if (state == "ARGLIST") {
    if (tok_eq(peek(tokens), "SYMBOL", ")")) {
      return _array();
    } else {
      let buffer = _array();
      while (true) {
        let tok = next_token_(tokens);
        if (_get(tok, 0) != "IDENTIFIER") {
          raise "bad arg: " + _get(tok, 1);
        }
        do buffer.push(tok);
        let popped = next_token_(tokens);
        if (false == tok_eq(popped, "SYMBOL", ",")) {
          do tokens.push(popped); # return the token
            return buffer;
        }
      }
    }
  } else if (state == "DEF") {
    let name_ = next_token_(tokens);
    if (_get(name_, 0) != "IDENTIFIER") {
      raise "bad function name: " + _get(name_, 1);
    }

    let paren_tok = next_token_(tokens);
    if (false == tok_eq(paren_tok, "SYMBOL", "(")) {
      raise "def '" + _get(name_, 1) + "' missing '(': " + _get(paren_tok, 1);
    }

    let params = parse_("ARGLIST", tokens);

    let paren_tok = next_token_(tokens);
    if (false == tok_eq(paren_tok, "SYMBOL", ")")) {
      raise "def '" + _get(name_, 1) + "' missing ')': " + _get(paren_tok, 1);
    }

    let body = parse_("SCOPE", tokens);
    return _array("DEF", name_, params, body);
  } else if (state == "IF") {
    let paren_tok = next_token_(tokens);
    if (false == tok_eq(paren_tok, "SYMBOL", "(")) {
      raise "'if' missing '(': " + _get(paren_tok, 1);
    }

    let cond = parse_("EXPRESSION", tokens);

    let paren_tok = next_token_(tokens);
    if (false == tok_eq(paren_tok, "SYMBOL", ")")) {
      raise "'if' missing ')': " + _get(paren_tok, 1);
    }

    let then_ = parse_("SCOPE", tokens);

    if (tok_eq(peek(tokens), "IDENTIFIER", "else")) {
      do next_token_(tokens); # consume 'else'
      if (tok_eq(peek(tokens), "SYMBOL", "{")) {
        let else_ = parse_("SCOPE", tokens);
      } else if (tok_eq(peek(tokens), "RESERVED", "if")) {
        do next_token_(tokens); # consume 'if'
        let else_ = parse_("IF", tokens);
      } else {
        raise "bad 'else' branch: " + peek(_get(tokens, 1));
      }
    } else {
      let else_ = 0; # @hack
    }
    return _array("IF", cond, then_, else_);
  } else if (state == "WHILE") {
    let cond = parse_("EXPRESSION", tokens);
    let body = parse_("SCOPE", tokens);
    return _array("WHILE", cond, body);
  } else if (state == "RETURN") {
    let val = parse_("EXPRESSION", tokens);
    let semi_tok = next_token_(tokens);
    if (false == tok_eq(semi_tok, "SYMBOL", ";")) {
      raise "missing ';': " + _get(semi_tok, 1);
    }
    return _array("RETURN", val);
  } else if (state == "BREAK") {
    let semi_tok = next_token_(tokens);
    if (false == tok_eq(semi_tok, "SYMBOL", ";")) {
      raise "missing ';': " + _get(semi_tok, 1);
    }
    return _array("BREAK");
  } else if (state == "RAISE") {
    let val = parse_("EXPRESSION", tokens);
    let semi_tok = next_token_(tokens);
    if (false == tok_eq(semi_tok, "SYMBOL", ";")) {
      raise "missing ';': " + _get(semi_tok, 1);
    }
    return _array("RAISE", val);
  } else if (state == "ALLOC") {
    let target = next_token_(tokens);
    if (_get(target, 0) != "IDENTIFIER") {
      raise "bad alloc target: " + _get(target, 1);
    }

    let semi_tok = next_token_(tokens);
    if (false == tok_eq(semi_tok, "SYMBOL", ";")) {
      raise "missing ';': " + _get(semi_tok, 1);
    }

    return _array("RAISE", target);
  } else if (state == "STATEMENT") {
    let tok = next_token_(tokens);
    let type = _get(tok, 0);
    let val = _get(tok, 1);
    if (type == "RESERVED") {
      let STATEMENT_STARTERS = _array("let", "def", "if", "while", "return", "break", "do", "raise", "alloc");
      if (STATEMENT_STARTERS.includes(val)) {
        return parse_(val.toUpperCase(), tokens);
      } else {
        raise "unknown reserved word: " + val;
      }
    } else if (type) {
      raise "unexpected statement starting at: " + val + "; next token is: " + peek(tokens);
    } else { # @hack for type == undefined
      raise "unexpected end of input";
    }
  } else {
    raise "unimplemented state: " + state;
  }
}

def generate_code(tokens) {
  return tokens;
}

def string_escape(str) {
  def helper(char) {
    if (char == "\n") {
      return "\\n";
    } else if (char == "\t") {
      return "\\t";
    } else if (char == "\\") {
      return "\\\\";
    } else if (char == "\"") {
      return "\\\"";
    } else {
      return char;
    }
  }

  let arr = str.split("");
  let arr = arr.map(helper);
  return arr.join("");
}

def _tokens_to_string(tokens) {
  def helper(tok) {
    let type = _get(tok, 0);
    let val = _get(tok, 1);
    let val_to_print = string_escape(val);

    return "[ :" + type + ", \"" + val_to_print + "\" ],";
  }

  let buf = _array("[");
  let buf = buf.concat(tokens.map(helper));
  do buf.push("]");
  return buf.join("\n");
}

let _ = _ARGV();
let infile = _get(_, 0);
let outfile = _get(_, 1);
let text = _readFile(infile);
let tokens = tokenize(text);
do _writeFile("ahuff/boot_tokens.txt", _tokens_to_string(tokens));
let ast = parse_entrypoint(tokens);
do _writeFile("ahuff/boot_ast.txt", _inspect(ast));
# let code = generate_code(ast);
# do _writeFile(outfile, code);
